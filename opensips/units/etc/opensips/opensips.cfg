####### Global Parameters #########
#!define FL_DP_OK 1
log_level=2
xlog_level=3
stderror_enabled=yes
syslog_enabled=yes
syslog_facility=LOG_LOCAL0
mhomed=1
#auto_aliases = yes
disable_503_translation=yes

# Worker Optimization
udp_workers=8

# Database Optimization
db_default_url = "postgres://opensips:NsvpUSgQfuzb8AHQ@localhost/opensips"
db_max_async_connections = 512

socket=udp:*:5060

####### Modules Section ########
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules/"

loadmodule "acc.so"
loadmodule "avpops.so"
loadmodule "db_postgres.so"
loadmodule "dialog.so"
loadmodule "dialplan.so"
loadmodule "httpd.so"
loadmodule "json.so"
loadmodule "load_balancer.so"
loadmodule "maxfwd.so"
loadmodule "mi_fifo.so"
loadmodule "mi_http.so"
loadmodule "nathelper.so"
loadmodule "permissions.so"
loadmodule "proto_tcp.so"
loadmodule "proto_udp.so"
loadmodule "proto_ws.so"
loadmodule "registrar.so"
loadmodule "rtpproxy.so"
loadmodule "rr.so"
loadmodule "signaling.so"
loadmodule "sipmsgops.so"
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "textops.so"
loadmodule "uac.so"
loadmodule "userblacklist.so"
loadmodule "usrloc.so"

#### Transaction Module
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 60)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)

#### Record Route Module
modparam("rr", "append_fromtag", 0)

#### User Location Module
modparam("usrloc", "nat_bflag", "NAT")
modparam("usrloc", "working_mode_preset", "single-instance-no-db")

#### Registrar Module
modparam("registrar", "tcp_persistent_flag", "TCP_PERSISTENT")

#### NAT Helper Module
modparam("nathelper", "natping_interval", 15)
modparam("nathelper", "ping_nated_only", 1)

### MI HTTP
modparam("httpd", "port", 8989)

#### ACCounting module
modparam("acc", "early_media", 0)
modparam("acc", "report_cancels", 1)
modparam("acc", "detect_direction", 0)
modparam("acc", "db_table_missed_calls", "acc")
modparam("acc", "extra_fields", "db: src_ip; dst_ip; agent; prefix; carrier")

#### Dialog module
modparam("dialog", "enable_stats", 1)
modparam("dialog", "profiles_with_value","caller")
modparam("dialog", "dlg_match_mode", 2)
modparam("dialog", "default_timeout", 1800)
modparam("dialog", "db_mode", 1)

#### Permission
modparam("permissions", "partition", "inbound: table_name = address")

#### Load Balancer
modparam("load_balancer", "probing_reply_codes", "501,404,403")
modparam("load_balancer", "probing_verbose", 1)

#### RTPProxy
modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7890")

####### Routing Logic ########

route {

  # Max-Forwards check
  if (!mf_process_maxfwd_header(10)) {
    send_reply(483, "Too Many Hops");
    exit;
  }

  # Initial checks for dialog
  if (has_totag()) {
    if (is_method("ACK") && t_check_trans()) {
      t_relay();
      exit;
    }

    if (!loose_route()) {
      send_reply(404, "Not here");
      exit;
    }

    if (is_method("BYE")) {
      do_accounting("db", "failed");
      xlog("L_INFO", "CALL ENDED, $ru, $ci, $fn, $fu\n");
    }

    route(relay);
    exit;
  }

  # Handle Unauthorized Requests (Prevent Open Relay)
  if (!is_myself("$rd") && !is_myself("$fd")) {
    if (($rU != NULL && dp_translate(1, $rU)) || ($tU != NULL && dp_translate(1, $tU)) ) {
      xlog("L_INFO", "Transit allowed by dialplan (rU=$rU, tU=$tU)\n");
    } else {
      xlog("L_INFO", "BLOCKED UNAUTHORIZED RELAY: $fu -> $tu (rU=$rU tU=$tU)\n");
      send_reply(403, "Forbidden");
      exit;
    }
  }

  t_check_trans();

  if (!is_method("REGISTER") && !is_myself("$rd") && !is_myself("$fd")) {

    # --- transit call: allow if dialplan permits rU or tU ---
    $var(dp_ok) = 0;

    # (Optional) avoid rewriting $rU when just "checking"
    $var(_rU) = $rU;
    if ($rU != NULL && dp_translate(1, $rU)) {
      $rU = $var(_rU);     # restore to avoid rewrite here
      $var(dp_ok) = 1;
    } else if ($tU != NULL && dp_translate(1, $tU)) {
      $var(dp_ok) = 1;
    }

    if (!$var(dp_ok)) {
      xlog("L_INFO", "BLOCKED UNAUTHORIZED RELAY: $fu -> $tu (rU=$rU tU=$tU)\n");
      send_reply(403, "Relay Forbidden");
      exit;
    }

    xlog("L_INFO", "Transit allowed by dialplan (rU=$rU, tU=$tU)\n");
  }

  if (!is_method("REGISTER|MESSAGE")) record_route();

  # Handle REGISTER requests
  if (is_method("REGISTER")) {
    if (!save("location")) {
      xlog("L_INFO", "Failed to register AoR $tu\n");
    }
    exit;
  }

  # Preloaded Route header check
  if (loose_route()) {
    xlog("L_INFO", "Attempt to route with preloaded Route's [$fu/$tu/$ru/$ci]"); 
    if (!is_method("ACK")) send_reply(403, "Preload Route denied");
    exit;
  }

  if (is_method("PUBLISH|SUBSCRIBE")) {
    send_reply(503, "Service Unavailable");
    exit;
  }

  # Handle CANCEL call
  if (is_method("CANCEL")) {
    xlog("L_INFO", "CALL CANCELLED,$ru,$ci,$fn,$fu\n");
    if (t_check_trans()) t_relay();
    exit;
  }

  # Handle INVITE (Call Processing)
  if (is_method("INVITE")) {
    create_dialog("B");
    do_accounting("db|db", "cdr|missed");
    $acc_extra(src_ip) = $si;
    $acc_extra(agent) = $rU;
    xlog("L_INFO", "CALL, $ru, $ci, $fn, $fu\n");
    route(DID_ROUTING);
  }

  # Reject unknown destinations
  if (!is_myself("$rd")) {
    append_hf("P-hint: outbound\r\n");
    route(relay);
  } else {
    send_reply(404, "Destination Not Found");
    exit;
  }
  
  # White list 
  if ($rU==NULL) {
    if ($si == "127.0.0.1") {
      t_reply(200, "OK");
      exit;
    } else {
      send_reply(484, "Address Incomplete");
      exit;
    }
  }

  # do lookup with method filtering
  if (!lookup("location","method-filtering")) {
    t_reply(404, "Not Found");
    exit;
  }

  do_accounting("log", "missed");
}

route[DID_ROUTING] {
  $var(exten_len) = $(rU{s.len});
  if ( $var(exten_len) == 10 ) {
    $acc_extra(prefix) = 0;
  } else if ( $var(exten_len) == 12 ) {
    $acc_extra(prefix) = $(rU{s.substr,0,2});
  } else if ( $var(exten_len) == 13 ) {
    $acc_extra(prefix) = $(rU{s.substr,0,3});
  } else if ( $var(exten_len) == 14 ) {
    $acc_extra(prefix) = $(rU{s.substr,0,4});
  } else {
    $acc_extra(prefix) = 0;
  }

  if (!check_blacklist("userblacklist")) {
    xlog("L_INFO", "NOTICE: $rU is blacklisted\n");
    acc_db_request("Blacklisted", "acc");
    sl_send_reply(504, "Blacklisted");
    exit;
  }

  $acc_extra(carrier) = "Undefined";

  # Keep original called domain before touching the R-URI
  $var(orig_rd) = $rd;

  # DID = user part of current R-URI
  $var(did) = $tU;
  if ($var(did) == "" || $var(did) == NULL) {
    $var(did) = $rU;
    xlog("L_INFO", "DP: Using R-URI username as DID='$var(did)'\n");
  } else {
    xlog("L_INFO", "DP: Using To header username as DID='$var(did)'\n");
  }

  # Outputs from dialplan: replacement and attrs
  $var(repl)  = "";
  $var(attrs) = "";

  # dp_translate(dpid:int, in_pv, out_pv, attrs_pv)
  if (!dp_translate(1, $var(did), $var(repl), $var(attrs))) {
    xlog("L_INFO", "DP: no match for DID='$var(did)'\n");
    # acc_db_request("Dialplan no matching rule", "acc");
    sl_send_reply(404, "No route for DID");
    exit;
  }

  xlog("L_INFO", "DP: in='$var(did)'  repl='[$var(repl)]'  attrs='[$var(attrs)]'\n");

  # Extract via attrs first (preferred: host=..;port=..;proto=udp)
  $var(host)  = $(var(attrs){param.value,host});
  $var(port)  = $(var(attrs){param.value,port});
  $var(proto) = $(var(attrs){param.value,proto});   # optional

  # If attrs are empty, interpret $var(repl)
  if ($var(host) == "" || $var(host) == NULL) {
    if ($var(repl) =~ "^sip:") {
      # Full SIP URI returned -> use it directly and relay
      seturi("$var(repl)");
      append_hf("X-Orig-DID: $var(did)\r\n");
      append_hf("Diversion: <sip:$var(did)@$var(orig_rd)>;reason=unconditional;screen=no;privacy=off\r\n");
      route(relay); exit;
    } else if ($var(repl) =~ ":") {
      # Contains colon - extract host and port using regex
      $var(host) = $(var(repl){re.subst,/^([^:]+):.*$/\1/});
      $var(port) = $(var(repl){re.subst,/^[^:]+:([0-9]+).*$/\1/});
      xlog("L_INFO", "DP: regex extracted host='$var(host)' port='$var(port)'\n");
    } else {
      # No colon - just hostname
      $var(host) = $var(repl);
      $var(port) = "5060";
      xlog("L_INFO", "DP: no port in repl, using host='$var(host)' port='$var(port)'\n");
    }
  }

  # Final validation
  if ($var(host) == "" || $var(host) == NULL) {
    xlog("L_ERR", "DP matched but host is empty (repl='[$var(repl)]' attrs='[$var(attrs)]')\n");
    acc_db_request("Dialplan misconfigured", "acc");
    sl_send_reply(500, "DP Misconfigured");
    exit;
  }

  if ($var(port) == "" || $var(port) == NULL) {
    $var(port) = "5060";
  }

  xlog("L_INFO", "DP: building URI with host='$var(host)' port='$var(port)'\n");

  # Build a clean R-URI
  seturi("sip:$var(did)@$var(host):$var(port)");

  # If you truly need TCP/TLS transport parameter
  # if ($var(proto) == "tcp") seturi("sip:$var(did)@$var(host):$var(port);transport=tcp");
  # else if ($var(proto) == "tls") seturi("sip:$var(did)@$var(host):$var(port);transport=tls");

  append_hf("X-Orig-DID: $var(did)\r\n");
  append_hf("Diversion: <sip:$var(did)@$var(orig_rd)>;reason=unconditional;screen=no;privacy=off\r\n");
  
  $acc_extra(dst_ip) = $var(host);

  t_on_failure("missed_call");
  route(relay);
}

route[relay] {
  if (is_method("INVITE")) {
    t_on_branch("per_branch_ops");
    t_on_reply("handle_nat");
    t_on_failure("missed_call");

    if (has_body("application/sdp")) {
      if (rtpproxy_offer("co")) {
        xlog("L_INFO", "RTPProxy offer engaged for call from $si to $ru\n");
      } else {
        xlog("L_ERR", "RTPProxy offer FAILED for call from $si\n");
      }
    }
  }

  if (!t_relay()) {
    send_reply(500, "Internal Error");
  }

  exit;
}

branch_route[per_branch_ops] {
  xlog("L_INFO", "New branch at $ru\n");
}

onreply_route[handle_nat] {
  if (has_body("application/sdp")) {
    if (t_check_status("(180)|(183)|2[0-9][0-9]")) {
      if (rtpproxy_answer("co")) {
        xlog("L_INFO", "RTPProxy answer engaged for reply\n");
      } else {
        xlog("L_ERR", "RTPProxy answer FAILED\n");
      }
    }
  }
  if (nat_uac_test("private-contact,private-sdp")) {
    xlog("L_INFO", "NAT detected, fixing contact\n");
    fix_nated_contact();
  }
}

failure_route[missed_call] {
  xlog("L_INFO", "Failure route - status: $T_reply_code\n");
  
  if (t_was_cancelled()) {
    xlog("L_INFO", "Transaction was cancelled\n");
    rtpproxy_unforce();
    exit;
  }

  if (t_check_status("486")) {
    xlog("L_INFO", "Call failed: Busy ($ru, $ci, $fn, $fu)\n");
    acc_db_request("Busy Call", "acc");
  }
  
  rtpproxy_unforce();
}